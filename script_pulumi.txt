import pulumi
import pulumi_aws as aws
import json

# Variables
region = "us-east-1"
image_uri = "joel02xd/api-students:latest"  # Imagen DockerHub
container_port = 8000
health_path = "/students"

# VPC y Subnets por defecto
vpc = aws.ec2.get_vpc(default=True)
subnets = aws.ec2.get_subnets(filters=[aws.ec2.GetSubnetsFilterArgs(
    name="vpc-id", values=[vpc.id]
)])

# Security Groups
alb_sg = aws.ec2.SecurityGroup("alb-sg",
    vpc_id=vpc.id,
    ingress=[aws.ec2.SecurityGroupIngressArgs(
        protocol="tcp", from_port=80, to_port=80, cidr_blocks=["0.0.0.0/0"]
    )],
    egress=[aws.ec2.SecurityGroupEgressArgs(
        protocol="-1", from_port=0, to_port=0, cidr_blocks=["0.0.0.0/0"]
    )]
)

task_sg = aws.ec2.SecurityGroup("task-sg",
    vpc_id=vpc.id,
    ingress=[aws.ec2.SecurityGroupIngressArgs(
        protocol="tcp", from_port=container_port, to_port=container_port,
        security_groups=[alb_sg.id]
    )],
    egress=[aws.ec2.SecurityGroupEgressArgs(
        protocol="-1", from_port=0, to_port=0, cidr_blocks=["0.0.0.0/0"]
    )]
)

# CloudWatch Logs
log_group = aws.cloudwatch.LogGroup("app-logs",
    retention_in_days=7
)

# ECS Cluster
cluster = aws.ecs.Cluster("flask-cluster")

# Función para crear container_definitions como JSON
def create_container_definitions(log_group_name):
    return json.dumps([{
        "name": "flask",
        "image": image_uri,
        "portMappings": [{"containerPort": container_port}],
        "logConfiguration": {
            "logDriver": "awslogs",
            "options": {
                "awslogs-group": log_group_name,
                "awslogs-region": region,
                "awslogs-stream-prefix": "flask"
            }
        },
        "healthCheck": {
            "command": ["CMD-SHELL", f"curl -f http://localhost:{container_port}{health_path} || exit 1"],
            "interval": 30,
            "timeout": 5,
            "retries": 3,
            "startPeriod": 10
        }
    }])

# Usamos LabRole como execution role
role = aws.iam.get_role(name="LabRole")

# Task Definition
task_def = aws.ecs.TaskDefinition("flask-task",
    family="flask-task",
    cpu="256",
    memory="512",
    network_mode="awsvpc",
    requires_compatibilities=["FARGATE"],
    execution_role_arn=role.arn,  # ✅ LabRole
    container_definitions=log_group.name.apply(create_container_definitions)
)

# Load Balancer
alb = aws.lb.LoadBalancer("app-lb",
    internal=False,
    load_balancer_type="application",
    security_groups=[alb_sg.id],
    subnets=subnets.ids
)

target_group = aws.lb.TargetGroup("app-tg",
    port=container_port,
    protocol="HTTP",
    target_type="ip",
    vpc_id=vpc.id,
    health_check=aws.lb.TargetGroupHealthCheckArgs(
        path=health_path,
        matcher="200-399"
    )
)

listener = aws.lb.Listener("app-listener",
    load_balancer_arn=alb.arn,
    port=80,
    default_actions=[aws.lb.ListenerDefaultActionArgs(
        type="forward",
        target_group_arn=target_group.arn
    )]
)

# ECS Service
service = aws.ecs.Service("flask-service",
    cluster=cluster.arn,
    task_definition=task_def.arn,
    desired_count=1,
    launch_type="FARGATE",
    network_configuration=aws.ecs.ServiceNetworkConfigurationArgs(
        subnets=subnets.ids,
        security_groups=[task_sg.id],
        assign_public_ip=True
    ),
    load_balancers=[aws.ecs.ServiceLoadBalancerArgs(
        target_group_arn=target_group.arn,
        container_name="flask",
        container_port=container_port
    )],
    opts=pulumi.ResourceOptions(depends_on=[listener])
)

# Output
pulumi.export("alb_dns", alb.dns_name)
